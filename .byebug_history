c
current_date
c
current_date
gvhgvhgvgvghvhvvvvvvvv/////////////////////////////////////////////////////////
c
ApplicationRecord.current_scope
ApplicationRecord.current_date
ApplicationRecord
ApplicationRevord
Application.all
Applicationall
Application.current_date = current_date
c
@date = current_date
c
session[:current_date] = (params[:date].present?) ? params[:date].to_date : session[:current_date]
(params[:date].blank?) && (session[:current_date].nil?)
params
c
@date = current_date
tyhntyhtyhtyhtyhyybytntyytbtytytyhty
c
@task.toggle :flag
c
 @task.update_attribute(:flag, 'true')
c
user.owner?(record.try(:parent_task).list) || record.try(:parent_task).user == user
record.is_blocker?
c
record.try(:parent_task)
record.try(:task)
record.try(:parent_task).list
record.try(:parent_task)
record
record.try(:task_parent)
record.try(:list)
user
user.owner?(record.try(:list))
c
current_date
params
c
user.owner?(record.try(:list)) || record.try(:user) == user
exit
user.owner?(record.try(:list)) 
 record.try(:user) == user
user.owner?(record.try(:list_id))
record.try(:list_id)
c
@invitation.save
c
recipient = User.find_by_email(recipient_email)
c
InvitationMailer.send_invitation(@invitation, @url).deliver_now
@url = sign_up_url(:invitation_token => @invitation.token)
c
recipient = User.find_by_email(recipient_email)
c
recipient = User.find_by_email(recipient_email)
c
InvitationMailer.send_invitation(@invitation, @url).deliver_now
  @url = sign_up_url(:invitation_token => @invitation.token)
@invitation
 @invitation.recipient 
c
User.find_by_email(recipient_email)
c
recipient
User.find_by_email(recipient_email)
c
@invitation
c
@invitation.sender_id
@invitation
c
self.user_id
status = 'changelist'
 status
status: status
num_list_change = self.user.num_incompleted_tasks(List.find(list))
num = self.user.num_incompleted_tasks(List.find(self.list_before))
self.previous_changes[:list_id].last
    self.previous_changes[:list_id].first
    list = self.list_id
    user = self.user_id
    partial = 'task'
   else
     list = self.parent_task.list_id
     user = self.parent_task.user_id
     partial = 't_blocker'
if (is_blocker?)
c
user
self
render_task(self,partial)
c
self
c
html
c
self
c
self
c
self
c
self
selft
c
=> 67:       self.previous_changes[:list_id].first != self.previous_changes[:list_id].last)
 (self.previous_changes.key?(:list_id) &&
self
self.previous_changes.key?(:list_id)
c
session[:list_id]
params
c
session[:list_id]
c
session[:list_id]
c
session[:list_id]
params
c
session[:list_id]
params
c
session[:list_id]
c
session[:list_id]
c
params
c
session[:list_id]
params
c
params
session[:list_id]
c
session[:list_id]
c
@user.errors.count
@user.errors.any?
@user.errors.any
c
@user.errors
@user.error
@user
c
invitation.recipient_email
exit
is_blocker?
self
params
c
@user.save
 @token = params[:invitation_token]
@user = User.create(user_params)
user_params
exit
params
c
session[:list_id]
c
params
c
session[:list_id]
params
c
session[:list_id]
params
c
params
session[:list_id]
parms
c
session[:list_id]
params
c
session[:list_id]
params
c
session[:list_id]
c
params
c
session[:list_id]
c
session[:list_id]
List.current
c
params
c
List.current
List_current
session[:list_id]
current_list
params
c
params
parms
session[:list_id]
c
List.current
current_list
cuerrent_list
@list
c
params
c
params
c
task_params
tastask_params
c
current_user
@task = current_list.tasks.build(task_params,user_id: current_user.id )
current_list
params
c
params
self
c
current_list
params
c
session[:list_id]
List.current
current_list
 params[:id].blank?
c
@list = List.find(params[:id])
params[:id].blank?
c
 @list = List.find(params[:id])
params[:id]
params[:id].blank?
c
current_list
params[:id]
params[:id].blank?
c
List.current
@_current_list = List.current = @list
session[:list_id] = params[:list_id]
List.current
 @_current_list = session[:list_id] = nil
List.current
@list != List.current
@list = List.find(params[:list_id])
exit
@list = List.find(params[:list_id])
c
List.current
@_current_list
